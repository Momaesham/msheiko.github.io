# Standarts

[PSR standarts](https://svyatoslav.biz/misc/psr_translation/)

---

# Error handling

```php
error_reporting(E_ALL);
ini_set('display_errors', 1);
```

# Cast types

* (int), (integer) - приведение к integer
* (bool), (boolean) - приведение к boolean
* (float), (double), (real) - приведение к float
* (string) - приведение к string
* (array) - приведение к array
* (object) - приведение к object
* (unset) - приведение к NULL

```php
$foo = 10;   // $foo - это целое число
$bar = (boolean) $foo;   // $bar - это булев тип
```

# Variables predefined

```php
$_GET     = &$HTTP_GET_VARS;
$_POST    = &$HTTP_POST_VARS;
$_ENV     = &$HTTP_ENV_VARS;
$_SERVER  = &$HTTP_SERVER_VARS;
$_COOKIE  = &$HTTP_COOKIE_VARS;
$_REQUEST = array_merge($_GET, $_POST, $_COOKIE);
```

# Constants

*Константа* - это идентификатор (имя) для простого значения. Как следует из названия, их значение не может изменится в ходе выполнения скрипта (кроме магических констант, которые на самом деле не являются константами). Имена констант по умолчанию чувствительны к регистру. По принятому соглашению, имена констант всегда пишутся в верхнем регистре.

```php
// Правильные имена констант
define("FOO",     "что-то");
define("FOO2",    "что-то ещё");
define("FOO_BAR", "что-то большее");

// Неправильные имена констант
define("2FOO",    "что-то");

// Это верное объявление, но лучше его не использовать:
// PHP однажды может зарегистрировать волшебную константу,
// которая нарушит работу скрипта
define("__FOO__", "что-то");
```
---

# Magic constants

| Имя |	Описание|
|---|---|
| `__LINE__` |	Текущий номер строки в файле.|
| `__FILE__` |	Полный путь и имя текущего файла с развернутыми симлинками. Если используется внутри подключаемого файла, то возвращается имя данного файла.|
| `__DIR__` |	Директория файла. Если используется внутри подключаемого файла, то возвращается директория этого файла. Это эквивалентно вызову dirname(`__FILE__`). Возвращаемое имя директории не оканчивается на слеш, за исключением корневой директории.|
| `__FUNCTION__` |	Имя функции или {closure} в случае анонимной функции.|
| `__CLASS__` |	Имя класса. Это имя содержит название пространства имен, в котором класс был объявлен (например, `Foo\Bar`). Обратите внимание, что начиная с PHP 5.4 `__CLASS__` также работает в трейтах. При использовании в методах трейтов `__CLASS__` является именем класса, в котором эти методы используется.|
| `__TRAIT__` |	Имя трейта. Это имя содержит название пространства имен, в котором трейт был объявлен (например, `Foo\Bar)`.|
| `__METHOD__` |	Имя метода класса.|
| `__NAMESPACE__` |	Имя текущего пространства имен.|
|`ClassName::class` |	Полное имя класса (с указанием пространства имен).|

---

# include/require

Выражение `include` включает и выполняет указанный файл.

`require` аналогично `include`, за исключением того, что при ошибке он также выдаст фатальную ошибку уровня `E_COMPILE_ERROR`. Другими словами, он остановит выполнение скрипта, тогда как `include` только выдал бы предупреждение `E_WARNING`, которое позволило бы скрипту продолжить выполнение.

Файлы включаются исходя из пути указанного файла, или, если путь не указан, используется путь, указанный в директиве `include_path`. Если файл не найден в `include_path`, `include` попытается проверить директорию, в которой находится текущий включающий скрипт и текущую рабочую директорию перед тем, как выдать ошибку. Конструкция `include` **выдаст предупреждение**, если не сможет найти файл; поведение отлично от `require`, который выдаст **фатальную ошибку**.


---

# require_once/include_once

Выражение `include_once` включает и выполняет указанный файл во время выполнения скрипта. Его поведение идентично выражению `include`, с той лишь разницей, что если код из файла уже один раз был включен, он не будет включен и выполнен повторно и вернёт `TRUE`. Как видно из имени, он включит файл только один раз.

Выражение `require_once` аналогично `require` за исключением того, что PHP проверит, включался ли уже данный файл, и если да, не будет включать его еще раз.

---

# Functions

```php

function foo($arg_1, $arg_2, /* ..., */ $arg_n)
{
    echo "Пример функции.\n";
    return $retval;
}
```

Внутри функции можно использовать любой корректный PHP-код, в том числе другие функции и даже объявления классов.

---

# Functions arguments

### Пример #1 Передача массива в функцию
```php
<?php
function takes_array($input)
{
    echo "$input[0] + $input[1] = ", $input[0]+$input[1];
}
?>
```

###Пример #2 Передача аргументов по ссылке
```php
<?php
function add_some_extra(&$string)
{
    $string .= 'и кое-что еще.';
}
$str = 'Это строка, ';
add_some_extra($str);
echo $str;    // выведет 'Это строка, и кое-что еще.'
?>
```

### Пример #3 Использование значений по умолчанию в определении функции
```php
<?php
function makecoffee($type = "капучино")
{
    return "Готовим чашку $type.\n";
}
echo makecoffee();
echo makecoffee(null);
echo makecoffee("эспрессо");
?>
```

```
Готовим чашку капучино.
Готовим чашку .
Готовим чашку эспрессо.
```

### Пример #4 Использование нескалярных типов в качестве значений по умолчанию
```php
<?php
function makecoffee($types = array("капучино"), $coffeeMaker = NULL)
{
    $device = is_null($coffeeMaker) ? "вручную" : $coffeeMaker;
    return "Готовлю чашку ".join(", ", $types)." $device.\n";
}
echo makecoffee();
echo makecoffee(array("капучино", "лавацца"), "в чайнике");
?>
```
Значение по умолчанию должно быть константным выражением, а не (к примеру) переменной или вызовом функции/метода класса.

Обратите внимание, что все аргументы, для которых установлены значения по умолчанию, должны находиться правее аргументов, для которых значения по умолчанию не заданы, в противном случае ваш код может работать не так, как вы этого ожидаете. 

###Пример #5 Некорректное использование значений по умолчанию

```php
<?php
function makeyogurt($type = "ацидофил", $flavour)
{
    return "Готовим чашку из бактерий $type со вкусом $flavour.\n";
}
 
echo makeyogurt("малины");   // Не будет работать так, как мы могли бы ожидать
?>
```
---

# Объявления типов

Объявления типов позволяют функциям строго задавать тип передаваемых параметров. Передача в функцию значений несоответствующего типа будет приводить к ошибке: в PHP 5 это будет обрабатываемая фатальная ошибка, а в PHP 7 будет выбрасываться исключение `TypeError`.

Чтобы объявить тип агрумента, необходимо перед его именем добавить имя требуемого типа. Объявление типов может принимать значения `NULL`, если значение по умолчанию для аргумента является `NULL`.

|Тип	|Описание	|Минимальная версия PHP|
|---|---|---|
|`Имя класса/интерфейса`|	Агрумент должен быть `instanceof`, что и имя класса или интерфейса.	|PHP 5.0.0|
|`self`|	Этот параметр должен быть `instanceof` того же класса, в методе которого он указан. Это можно использовать только в методах класса или экземпляра.	|PHP 5.0.0|
|`array`|	Аргумент должен быть типа `array`.	|PHP 5.1.0|
|`callable`|	Аргумент должен быть корректным callable-типом.|	PHP 5.4.0|
|`bool`|	Аргумент должен быть типа `boolean`.|	PHP 7.0.0|
|`float`|	Аргумент должен быть типа `float`.	|PHP 7.0.0|
|`int`|	Аргумент должен быть типа `integer`.|	PHP 7.0.0|
|`string`|	Аргумент должен иметь тип `string`.	|PHP 7.0.0|
|`iterable`|	Параметр должен быть либо массивом, либо экземпляром класса, реализующего `Traversable`.|	PHP 7.1.0|
|`object`|	Параметр должен быть объектом (object).	|PHP 7.2.0|

--

# Строгая типизация 

По умолчанию PHP будет пытаться привести значения несоответствующих типов к скалярному типу, если это возможно. Например, если в функцию передается целое число (`integer`), а тип аргумента объявлен как строка (`string`), в итоге функция получит преобразованное в строку (`string`) значение.

Для отдельных файлов можно включать режим строгой типизации. В этом режиме в функцию можно передавать значения только тех типов, которые объявлены для аргументов. В противном случае будет выбрасываться исключение `TypeError`. Есть лишь одно исключение - целое число (`integer`) можно передать в функцию, которая ожидает значение типа float. Вызовы функций внутри встроенных функций не будут затронуты директивой `strict_types`.

Для включения режима строгой типизации используется выражение `declare` в объявлении `strict_types`:

    Предостережение

    Включение режима строгой типизации также повлияет на объявления типов возвращаемых значений.

# Возврат значений 

Значения возвращаются при помощи необязательного оператора возврата. Возвращаемые значения могут быть любого типа, в том числе это могут быть массивы и объекты. Возврат приводит к завершению выполнения функции и передаче управления обратно к той строке кода, в которой данная функция была вызвана.

Замечание:
Если конструкция return не указана, то функция вернет значение `NULL`.

### Пример #1 Использование конструкции return

```php
<?php
function square($num)
{
    return $num * $num;
}
echo square(4);   // выводит '16'.
?>
```


### Пример #2 Возврат нескольких значений в виде массива

```php
<?php
function small_numbers()
{
    return array (0, 1, 2);
}
list ($zero, $one, $two) = small_numbers();
?>
```

### Пример #4 Обычное объявление типа возвращаемого значения

```php
<?php
function sum($a, $b): float {
    return $a + $b;
}

// Будет возвращаться значение типа float.
var_dump(sum(1, 2));
?>
```

---

# Обращение к функциям через переменные

PHP поддерживает концепцию переменных функций. Это означает, что если к имени переменной присоединены круглые скобки, PHP ищет функцию с тем же именем, что и результат вычисления переменной, и пытается ее выполнить. Эту возможность можно использовать для реализации обратных вызовов, таблиц функций и множества других вещей.

```php
<?php
function foo() {
    echo "В foo()<br />\n";
}

function bar($arg = '')
{
    echo "В bar(); аргумент был '$arg'.<br />\n";
}

// Функция-обертка для echo
function echoit($string)
{
    echo $string;
}

$func = 'foo';
$func();        // Вызывает функцию foo()

$func = 'bar';
$func('test');  // Вызывает функцию bar()

$func = 'echoit';
$func('test');  // Вызывает функцию echoit()
?>
```

---

# Встроенные функции

[Link](http://php.net/manual/ru/funcref.php)

---

# Анонимные функции 

Анонимные функции, также известные как замыкания (`closures`), позволяют создавать функции, не имеющие определенных имен. Они наиболее полезны в качестве значений `callback-параметров`, но также могут иметь и множество других применений.

Анонимные функции реализуются с использованием класса `Closure`.

### Пример #1 Пример анонимной функции

```php
<?php
echo preg_replace_callback('~-([a-z])~', function ($match) {
    return strtoupper($match[1]);
}, 'hello-world');
// выведет helloWorld
?>
```


Замыкания также могут быть использованы в качестве значений переменных; PHP автоматически преобразует такие выражения в экземпляры внутреннего класса `Closure`. Присвоение замыкания переменной использует тот же синтаксис, что и для любого другого присвоения, включая завершающую точку с запятой:

### Пример #2 Пример присвоения анонимной функции переменной

```php
<?php
$greet = function($name)
{
    printf("Привет, %s\r\n", $name);
};

$greet('Мир');
$greet('PHP');
?>
```