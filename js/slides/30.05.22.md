# Массивы


Для хранения упорядоченных коллекций существует особая структура данных, которая называется массив, `Array`.

---

# Объявление

Существует два варианта синтаксиса для создания пустого массива:

```js
let arr = new Array();
let arr = [];
```

Практически всегда используется второй вариант синтаксиса. В скобках мы можем указать начальные значения элементов:

```js
let fruits = ["Яблоко", "Апельсин", "Слива"];
```

---

# Элементы

Элементы массива нумеруются, начиная с `нуля`.

Мы можем получить элемент, указав его номер в квадратных скобках:

```js run
let fruits = ["Яблоко", "Апельсин", "Слива"];

alert( fruits[0] ); // Яблоко
alert( fruits[1] ); // Апельсин
alert( fruits[2] ); // Слива
```

Мы можем заменить элемент:

```js
fruits[2] = 'Груша'; // теперь ["Яблоко", "Апельсин", "Груша"]
```

…Или добавить новый к существующему массиву:

```js
fruits[3] = 'Лимон'; // теперь ["Яблоко", "Апельсин", "Груша", "Лимон"]
```

---
# length

Общее число элементов массива содержится в его свойстве `length`:

```js run
let fruits = ["Яблоко", "Апельсин", "Слива"];

alert( fruits.length ); // 3
```

---

# элементы

В массиве могут храниться элементы любого типа.


```js 
// разные типы значений
let arr = [ 'Яблоко', { name: 'Джон' }, true, function() { alert('привет'); } ];

// получить элемент с индексом 1 (объект) и затем показать его свойство
alert( arr[1].name ); // Джон

// получить элемент с индексом 3 (функция) и выполнить её
arr[3](); // привет
```

---

# Висячая запятая

Список элементов массива может оканчиваться запятой:
```js
let fruits = [
  "Яблоко",
  "Апельсин",
  "Слива",
];
```

> "Висячая запятая" упрощает процесс добавления/удаления элементов, так как все строки становятся идентичными.

---

# Методы pop/push, shift/unshift


- `unshift` добавляет элемент в начало.
- `shift` удаляет элемент в начале, сдвигая очередь, так что второй элемент становится первым.
- `push` добавляет элемент в конец.
- `pop` удаляет последний элемент.

---

# pop

`pop` Удаляет последний элемент из массива и возвращает его:

```js run
let fruits = ["Яблоко", "Апельсин", "Груша"];

alert( fruits.pop() ); // удаляем "Груша" и выводим его

alert( fruits ); // Яблоко, Апельсин
```

> `fruits.pop()` и `fruits[2]` возвращают последний элемент массива, но `fruits.pop()` также изменяет массив, удаляя его.

---
# push

`push`  Добавляет элемент в конец массива:

```js run
let fruits = ["Яблоко", "Апельсин"];

fruits.push("Груша");

alert( fruits ); // Яблоко, Апельсин, Груша
```

> Вызов `fruits.push(...)` равнозначен `fruits[fruits.length] = ...`.

---

# shift

`shift`  Удаляет из массива первый элемент и возвращает его:

```js run
let fruits = ["Яблоко", "Апельсин", "Груша"];

alert( fruits.shift() ); // удаляем Яблоко и выводим его

alert( fruits ); // Апельсин, Груша
```

---

# unshift

`unshift` Добавляет элемент в начало массива:

```js run
let fruits = ["Апельсин", "Груша"];

fruits.unshift('Яблоко');

alert( fruits ); // Яблоко, Апельсин, Груша
```

---

# push/unshift

Методы `push` и `unshift` могут добавлять сразу несколько элементов:

```js run
let fruits = ["Яблоко"];

fruits.push("Апельсин", "Груша");
fruits.unshift("Ананас", "Лимон");

// ["Ананас", "Лимон", "Яблоко", "Апельсин", "Груша"]
alert( fruits );
```

---


# Эффективность

Методы `push/pop` выполняются быстро, а методы `shift/unshift` – медленно.

---

# Перебор элементов for

Одним из самых старых способов перебора элементов массива является цикл `for` по цифровым индексам:

```js run
let arr = ["Яблоко", "Апельсин", "Груша"];

*!*
for (let i = 0; i < arr.length; i++) {
*/!*
  alert( arr[i] );
}
```

---

# Перебор элементов for..of

Но для массивов возможен и другой вариант цикла, `for..of`:

```js run
let fruits = ["Яблоко", "Апельсин", "Слива"];

// проходит по значениям
for (let fruit of fruits) {
  alert( fruit );
}
```

Цикл `for..of` не предоставляет доступа к номеру текущего элемента, только к его значению, но в большинстве случаев этого достаточно. А также это короче.


```js run
let arr = ["Яблоко", "Апельсин", "Груша"];

*!*
for (let key in arr) {
*/!*
  alert( arr[key] ); // Яблоко, Апельсин, Груша
}
```

---

# Немного о "length"

Свойство `length` автоматически обновляется при изменении массива. Если быть точными, это не количество элементов массива, а наибольший цифровой индекс плюс один.

Например, единственный элемент, имеющий большой индекс, даёт большую длину:

```js run
let fruits = [];
fruits[123] = "Яблоко";

alert( fruits.length ); // 124
```


> Ещё один интересный факт о свойстве `length` – его можно перезаписать.

Если мы вручную увеличим его, ничего интересного не произойдёт. Зато, если мы уменьшим его, массив станет короче. Этот процесс необратим
```js run
let arr = [1, 2, 3, 4, 5];

arr.length = 2; // укорачиваем до двух элементов
alert( arr ); // [1, 2]

arr.length = 5; // возвращаем length как было
alert( arr[3] ); // undefined: значения не восстановились
```

> Таким образом, самый простой способ очистить массив – это `arr.length = 0;`.

---

# Многомерные массивы

Массивы могут содержать элементы, которые тоже являются массивами. Это можно использовать для создания многомерных массивов, например, для хранения матриц:

```js run
let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

alert( matrix[1][1] ); // 5, центральный элемент
```

---

# toString

Массивы по-своему реализуют метод `toString`, который возвращает список элементов, разделённых запятыми.

```js run
let arr = [1, 2, 3];

alert( arr ); // 1,2,3
alert( String(arr) === '1,2,3' ); // true
```
