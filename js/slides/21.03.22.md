# Селекторы

- Селекторы по ID
- Селекторы по классу
- Селектор по типу
- Селектор потомков
- Список селекторов
- Универсальные селекторы
- Селектор дочерних элементов
- Смежные селекторы
- Селектор следующего элемента

---

# Селекторы по ID

В HTML-документах CSS-селекторы по `ID` производят выборку всех элементов по `ID`, полностью совпадающих с селектором.

### Синтаксис

```css
#id_value {
    style: properties;
}
```

### Пример

```css
span#identified {
  background-color: DodgerBlue;
}

```

---

# Селектор по типу

CSS селекторы по типу выбирают элементы по имени узла. Используются отдельно, поэтому, селектор типа для конкретного имени тега выбирает все элементы этого типа, то есть с этим именем узла в документе.

### Синтаксис

```css
element { style properties }
```

### Пример

```css
span {
  background-color: DodgerBlue;
  color: #ffffff;
}
```

---

# Селекторы по классу

В HTML документе, селекторы по CSS классу находят элементы с нужным классом. Атрибут класса определяется как разделённый пробелами список элементов, и один из этих пунктов должен точно соответствовать имени класса, приведённому в селекторе.


### Синтаксис

```css
.classname { style properties }
```

### Пример

```css
span.classy {
  background-color: DodgerBlue;
}
```

---

# Селектор потомков

Комбинатор `␣` (пробел) представляет собой 2 или более селекторов, найдёт элементы соответствующие обоим селекторам. Селекторы по потомкам похожи на селекторы дочерних элементов, но они не учитывают вложенность элементов и применяют свои свойства ко всем элементам данного типа, находящимся внутри родительского элемента, независимо от глубины вложенности.

### Синтаксис

```css
selector1 selector2 {
    стили 
}
```

### Пример

```css
div span { 
    background-color: DodgerBlue;
}
```

---

#  Список селекторов

CSS список селекторов `,` выбирает все соответствующие элементы.

### Синтаксис

```css
element, element, element { свойства стиля }
```

### Пример

```css
h1, h2, h3, h4, h5, h6 { font-family: helvetica; }
```

---

# Универсальные селекторы

Звёздочка `*` - универсальный селектор для CSS. Соответствует любому тегу

### Синтаксис

```css
* { свойства стиля }
```

### Пример

```css
*[lang^=en]{color:green;}
*.warning {color:red;}
*#maincontent {border: 1px solid blue;}
```

---

# Селектор дочерних элементов

Комбинатор `>` разделяет 2 селектора, находит элементы заданные вторым селектором, являющие прямыми потомками для элементов отобранных первым селектором. Напротив, два селектора в селекторе потомков  находят элементы не обязательно являющиеся прямыми потомками, т.е. несмотря на количество "прыжков" до них в DOM.

### Синтаксис

```css
selector1 > selector2 { style properties }
```

### Пример

```css
span { background-color: white; }
div > span {
  background-color: DodgerBlue;
}
```

---

# Смежные селекторы

Указывает на смежный или следующий селектор. Обеспечивает выбор только элемента расположенного непосредственно за определённым в первой части элементом.

### Синтаксис

```css
former_element + target_element { style properties }
```

### Пример

```css
li + li {
  color: red;
}
```

---

# Селектор следующего элемента

Общий комбинатор смежных селекторов `~` разделяет два селектора и находит второй элемент только если ему предшествует первый, и они оба имеют общего родителя. Свойства будут применены ко всем элементам, указанным в правой части, следующим за элементом, указанным в левой части.

### Синтаксис

```css
element ~ element { style properties } }
```

### Пример

```css
p ~ span {
  color: red;
}
```

---

# Float

Элемент, для которого указано это свойство, частично выходит из потока: все элементы блочного контекста, прописанные в коде после элемента с `float`, занимают его место, а элементы строчного контекста — «обтекают» его.

Три значения свойства:

- `left` — элемент встанет у левого края родительского блока.
- `right` — элемент встанет у правого края родительского блока.
- `none` — значение по умолчанию, элемент останется в потоке.

```css
.element {
  float: left;
}
```

> Применяя `float` к элементу, мы неявно делаем его блочным.

Для отмены обтекания исползуется свойство `clear`

```css
.clearfix {
  clear: both;
}
```

---

# Колонки

в современном вебе разбивка текста на колонки применяется весьма редко, и чаще всего используется для стилизации под газетную вёрстку или для оформления художественных материалов

- column-count
- column-width
- column-fill
- column-span
- column-rule-color
- column-rule-style
- column-rule-width
- column-rule

---

# column-count

Свойство `column-count` управляет количеством колонок, на которые будет разбит контент элемента.

> Вместо числа допустимо ключевое слово `auto`

```css
p {
  column-count: 3;
}
```

---

# column-width

Свойство `column-width` управляет шириной колонок, на которые разбивается контент элемента.

> Можно указать ширину колонки в любых единицах измерения, кроме процентов. Значение должно быть положительным.

> Можно указать ключевое слово `auto`. Тогда ширина колонки будет определяться на основании количества колонок, заданного в свойстве `column-count`.

```css
p {
  column-width: 250px;
  column-width: 15vw;
  column-width: 10em;
}

p {
  column-count: 4;
  column-width: auto;
}

```

---

# column-fill

Свойство `column-fill` управляет тем, как контент в многоколоночной вёрстке будет разделяться на колонки в блоках с фиксированной высотой.

Можно указать одно из двух ключевых слов:

- `auto` колонки будут заполняться текстом последовательно
- `balance` (значение по умолчанию). браузер будет пытаться сбалансировать контент между колонками

```css
.item1 {
  column-fill: auto;
}

.item2 {
  column-fill: balance;
}
```

> `column-fill` учитывается только в том случае, если у блока с многоколоночным контентом задана высота. Иначе браузеры будут распределять контент по колонкам автоматически.

---

# column-span

Свойство `column-span` позволяет элементу растянуться на несколько колонок при многоколоночной вёрстке.

Можно указать одно из двух ключевых слов –` none` или `all`

- `none` элемент не будет растягиваться на несколько колонок. (значение по умолчанию.)
- `all` элемент выпадет из потока и растянется на все колонки. До и после него появятся переносы, контент до и после независимо разделится на колонки.

```css
h2 {
  column-span: all;
}
```

---

# column-rule-color

Свойство `column-rule-color` отвечает за цвет линии между колонками в многоколоночной вёрстке.

```css
p {
  column-count: 3;
  column-rule-color: red;
}

```

---

# column-rule-style

Свойство `column-rule-style` отвечает за стиль линии между колонками в многоколоночной вёрстке.

> Стиль межколоночной линии соответсвует ключевым словам из `border-style`

```css
p {
  column-count: 3;
  column-rule-style: dashed;
}

```

---

# column-rule-width

Свойство `column-rule-width` отвечает за ширину линии между колонками в многоколоночной вёрстке.

```css
p {
  column-count: 3;
  column-rule: 2px;
}

```

---

# column-rule

Свойство `column-rule` отвечает за внешний вид линии между колонками в многоколоночной вёрстке.

Свойство `column-rule` является шорткатом для свойств:

- `column-rule-width`
- `column-rule-style`
- `column-rule-color`

```css
p {
  column-rule: 2px dashed red;
}

```

---

# position

Позиционирование позволяет вам изымать элементы из нормального потока макета документа и заставить их вести себя по-другому; например, располагаться друг на друге или всегда оставаться на одном и том же месте внутри окна просмотра браузера

- static
- relative
- top, bottom, left, и right
- absolute
- fixed
- sticky 
- z-index

---

# position:static

Любой элемент, добавленный на страницу, будет иметь это значение и будет расположен в нормальном потоке документа согласно контексту форматирования родительского элемента

```css
.positioned {
  position: static;
  background: yellow;
}
```

---

# position:relative 

Элемент позиционируется так же, как и статичный, но его отображение может быть смещено относительно своего начального положения при помощи свойств `left`, `right`, `top`, `bottom`

> Это смещение чисто визуальное и не затрагивает положение соседних элементов, кроме случая, когда элемент выходит за границы родителя, имеющего возможность прокрутки

```css
div {
    position: relative;
}
```

---

# top, bottom, left, и right

`top`, `bottom`, `left` , и `right` используются вместе с `position` чтобы указать куда именно перемещать позиционируемый элемент.

```css
div{
    position: relative;
    top: 30px;
    left: 30px;
}
```

---

# position:absolute

задаём абсолютное позиционирование и при помощи свойств `lef`t, `right`, `top`, `bottom` регулируем положение элемента

Есть ряд особенностей такого позиционирования:

- Элемент убирается из основного потока документа. То есть, перестаёт влиять на положение окружающих элементов и на размер родителя. Можно представить себе, что элемент уходит на слой выше и перестаёт взаимодействовать со всеми элементами, кроме своих потомков.
- Элемент позиционируется относительно ближайшего позиционированного предка. То есть, браузер идёт вверх по дереву элементов и ищет ближайшего опорного родителя. И затем располагает наш элемент относительно этого родителя.
- Если элемент был частью строчного контекста форматирования, он приобретает блочный контекст форматирования. К нему становится применима блочная модель.
- Если элемент был блочным и занимал всю ширину своего родителя, то теперь его ширина будет определяться шириной контента.
- Отступы элемента с `position: absolute` не схлопываются с отступами соседних элементов.

```css
div{
    position: absolute;
}
```

---

# position:fixed

Позиционирует  элемент не относительно родителя, а относительно окна браузера вне зависимости от вложенности

```css
div{
    position: fixed;
}
```
У такого способа позиционирования есть ряд особенностей:

- Элемент убирается из основного потока документа. То есть, перестаёт влиять на положение окружающих элементов и на размер родителя. Можно представить себе, что элемент уходит на слой выше и перестаёт взаимодействовать со всеми элементами, кроме своих потомков.
- Элемент позиционируется относительно окна браузера


---

# position:sticky

Элемент с `position: sticky` «прилипает» к экрану при прокрутке, пока не встретится с границей родительского блока.

```css
.block {
  position: sticky;
  top: 15px;
}
```

> Для блока, который должен быть «липко» позиционирован, указываем `position: sticky` и позицию относительно окна браузера.

---

# z-index

Обычно элементы на странице располагаются только в двух измерениях — `x` (горизонталь) и `y` (вертикаль). Но в отдельных случаях, когда позиционирование элементов отличается от статичного, появляется третье измерение `z`, отвечающее за глубину.

Свойство `z-index` позволяет управлять порядком наложения элементов друг на друга.

```css
.selector {
  z-index: auto;
  z-index: 0;
  z-index: -1;
  z-index: 1;
  z-index: 9999999;
  z-index: -999999;
}

```
